package observatorium

import (
	"fmt"
	"maps"
	"net"
	"strings"
	"time"

	"github.com/bwplotka/mimic"
	"github.com/bwplotka/mimic/encoding"
	"github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/memcached"
	observatoriumapi "github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/observatorium/api"
	observatoriumup "github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/observatorium/up"
	"github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/prometheus/avalanche"
	"github.com/observatorium/observatorium/configuration_go/abstr/kubernetes/thanos/ruler"
	"github.com/observatorium/observatorium/configuration_go/k8sutil"
	"github.com/observatorium/observatorium/configuration_go/openshift"
	"github.com/observatorium/observatorium/configuration_go/schemas/log"
	upoptions "github.com/observatorium/up/pkg/options"
	templatev1 "github.com/openshift/api/template/v1"
	monv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	obsApiImage          = "quay.io/observatorium/api"
	obsApiTag            = "main-2023-12-06-62d7703"
	gubernatorImage      = "quay.io/app-sre/gubernator"
	gubernatorTag        = "v2.0.0-rc.36"
	observatoriumUpImage = "quay.io/observatorium/up"
	observatoriumUpTag   = "master-2022-03-24-098c31a"
	avalancheImage       = "quay.io/prometheuscommunity/avalanche"
	avalancheTag         = "main"
	obsctlReloaderImage  = "quay.io/app-sre/obsctl-reloader"
	obsctlReloaderTag    = "9c789b9"
	rulesObjstoreName    = "observatorium-rules-objstore"
	rulesObjstoreTag     = "main-2022-09-21-9df4d2c"
)

type ObservatoriumAPI struct {
	Namespace                    string
	Tenants                      []observatoriumapi.Tenant
	ThanosImageTag               string
	APIPremanifestsHook          func(*observatoriumapi.ObservatoriumAPIDeployment)
	CachePremanifestsHook        func(*memcached.MemcachedDeployment)
	GubernatorPremanifestsHook   func(*observatoriumapi.GubernatorDeployment)
	RBAC                         string
	AmsUrl                       string
	UpQueryFrontendOpts          func(*observatoriumup.UpOptions)
	UpQueryFrontendDeploy        func(*observatoriumup.UpDeployment)
	UpQueriesTenant              string
	AvalancheOpts                func(*avalanche.AvalancheOptions)
	AvalancheDeploy              func(*avalanche.AvalancheDeployment)
	ObsCtlReloaderManagedTenants []string
	RuleObjStoreSecret           string
	TemplateParams               []templatev1.Parameter
}

func (o *ObservatoriumAPI) Manifests(generator *mimic.Generator) {
	withStatusRemove := func(encoder encoding.Encoder) encoding.Encoder {
		return &statusRemoveEncoder{encoder: encoder}
	}

	generator.Add("observatorium-api-template.yaml", withStatusRemove(o.makeAPI()))
}

func (o *ObservatoriumAPI) makeAPI() encoding.Encoder {
	templateParams := []templatev1.Parameter{} // collects template params generated by subcomponents
	templateParams = append(templateParams, o.TemplateParams...)

	// Observatorium api config
	gubernatorName := "observatorium-gubernator"
	tenantsConfig := &observatoriumapi.Tenants{Tenants: o.Tenants}
	opts := &observatoriumapi.ObservatoriumAPIOptions{
		InternalTracingEndpoint:          "localhost:6831",
		LogLevel:                         log.LogLevelWarn,
		MiddlewareRateLimiterGrpcAddress: fmt.Sprintf("%s.%s.svc.cluster.local:8081", gubernatorName, o.Namespace),
		MetricsReadEndpoint:              fmt.Sprintf("http://%s.%s.svc.cluster.local:9090", obsQueryFrontendName, o.Namespace),
		MetricsWriteEndpoint:             fmt.Sprintf("http://%s.%s.svc.cluster.local:19291", receiveRouterName, o.Namespace),
		MetricsRulesEndpoint:             fmt.Sprintf("http://%s.%s.svc.cluster.local:8080", rulesObjstoreName, o.Namespace),
		MetricsAlertmanagerEndpoint:      fmt.Sprintf("http://%s.%s.svc.cluster.local:9093", alertManagerName, o.Namespace),
		TenantsConfig:                    observatoriumapi.NewTenantsConfig(tenantsConfig).AsSecret(),
	}

	if o.RBAC != "" {
		opts.RbacConfig = observatoriumapi.NewRbacConfig(nil).WithValue(o.RBAC)
	}

	// K8s config
	obsapi := observatoriumapi.NewObservatoriumAPI(opts, o.Namespace, obsApiTag)
	obsapi.Image = obsApiImage
	obsapi.Replicas = 1
	delete(obsapi.ContainerResources.Limits, corev1.ResourceCPU)
	opaAmsCache := "observatorium-api-cache-memcached"
	cacheURL := fmt.Sprintf("%s.%s.svc.cluster.local:11211", opaAmsCache, o.Namespace)

	amsOidcClientSecretName := "observatorium-ams-oidc-client-secret"
	amsSideCar := o.makeOpaAms(o.AmsUrl, cacheURL, amsOidcClientSecretName)
	amsSideCar.Secrets = map[string]map[string][]byte{
		amsOidcClientSecretName: {
			"client-id":     []byte("${AMS_OIDC_CLIENT_ID}"),
			"client-secret": []byte("${AMS_OIDC_CLIENT_SECRET}"),
			"issuer-url":    []byte("${AMS_OIDC_ISSUER_URL}"),
		},
	}
	templateParams = append(templateParams, templatev1.Parameter{Name: "AMS_OIDC_CLIENT_ID"})
	templateParams = append(templateParams, templatev1.Parameter{Name: "AMS_OIDC_CLIENT_SECRET"})
	templateParams = append(templateParams, templatev1.Parameter{Name: "AMS_OIDC_ISSUER_URL"})

	obsapi.Sidecars = []k8sutil.ContainerProvider{
		makeJaegerAgent("observatorium-tools"),
		amsSideCar,
	}

	// Execute preManifestsHook
	executeIfNotNil(o.APIPremanifestsHook, obsapi)

	// Post process
	manifests := obsapi.Manifests()
	postProcessServiceMonitor(k8sutil.GetObject[*monv1.ServiceMonitor](manifests, ""), obsapi.Namespace)
	addQuayPullSecret(k8sutil.GetObject[*corev1.ServiceAccount](manifests, ""))

	// Add rules objstore
	maps.Copy(manifests, o.makeRulesObjstore())

	// Add cache
	cachePreManHook := func(memdep *memcached.MemcachedDeployment) {
		memdep.CommonLabels[k8sutil.ComponentLabel] = "api-cache"
		executeIfNotNil(o.CachePremanifestsHook, memdep)
	}
	maps.Copy(manifests, makeMemcached(opaAmsCache, o.Namespace, cachePreManHook))

	// Add gubernator
	maps.Copy(manifests, o.makeGubernator(gubernatorName))

	// Add obsctl reloader
	maps.Copy(manifests, o.makeObsCtlReloader(obsapi.Name))

	// Add up query frontend
	endpoint := fmt.Sprintf("http://observatorium-thanos-query-frontend.%s.svc.cluster.local:9090", o.Namespace)
	maps.Copy(manifests, o.makeUp("observatorium-up-query-frontend", endpoint))

	// Add up ruler
	endpoint = fmt.Sprintf("http://observatorium-thanos-query-rule.%s.svc.cluster.local:9090", o.Namespace)
	maps.Copy(manifests, o.makeUp("observatorium-up-query-rule", endpoint))

	// Add avalanche
	maps.Copy(manifests, o.makeAvalanche())

	// Set encoders and template params
	cacheEncoder := NewStdTemplateYAML(opaAmsCache, "CACHE")
	templateParams = append(templateParams, cacheEncoder.TemplateParams()...)
	apiEncoder := NewStdTemplateYAML(obsapi.Name, "OBSAPI").WithLogLevel()
	templateParams = append(templateParams, apiEncoder.TemplateParams()...)
	template := openshift.WrapInTemplate("", manifests, metav1.ObjectMeta{
		Name: obsapi.Name,
	}, sortTemplateParams(templateParams))

	return cacheEncoder.Wrap(apiEncoder.Wrap(encoding.GhodssYAML(template[""])))
}

func (o *ObservatoriumAPI) makeRulesObjstore() k8sutil.ObjectMap {
	opts := ruler.NewRulesObjstoreDefaultOptions()
	// Not using the opts.ObjstoreConfigFile because it doesn't support setting the resource from an init container
	// Doing some manifest post processing instead
	opts.LogLevel = string(log.LogLevelWarn)
	opts.LogFormat = string(log.LogFormatLogfmt)

	rulesObjstore := ruler.NewRulesObjstore(opts, o.Namespace, rulesObjstoreTag)
	rulesObjstore.Name = rulesObjstoreName

	// Rules objstore expects a file with the objstore config.
	// We generate the file from the env vars using an init container
	// that writes the file to a shared volume.
	initContainer := corev1.Container{
		Name:            "init",
		Image:           "quay.io/app-sre/ubi8-ubi-minimal",
		ImagePullPolicy: corev1.PullIfNotPresent,
		Command: []string{
			"/bin/sh",
			"-c",
			"echo \"${OBJSTORE_CONFIG}\" > /tmp/config/config.yaml",
		},
		Env: objStoreEnvVars(o.RuleObjStoreSecret),
		VolumeMounts: []corev1.VolumeMount{
			{
				Name:      "objstore-config",
				MountPath: "/tmp/config",
			},
		},
	}

	manifests := rulesObjstore.Manifests()
	deployment := k8sutil.GetObject[*appsv1.Deployment](manifests, "")
	deployment.Spec.Template.Spec.InitContainers = []corev1.Container{initContainer}
	deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, corev1.Volume{
		Name: "objstore-config",
		VolumeSource: corev1.VolumeSource{
			EmptyDir: &corev1.EmptyDirVolumeSource{},
		},
	})
	mainContainer := &deployment.Spec.Template.Spec.Containers[0]
	mainContainer.VolumeMounts = append(mainContainer.VolumeMounts, corev1.VolumeMount{
		Name:      "objstore-config",
		MountPath: "/etc/rules-objstore/objstore",
		ReadOnly:  true,
	})
	mainContainer.Args = append(mainContainer.Args, "-objstore.config-file=/etc/rules-objstore/objstore/config.yaml")

	return manifests
}

func (o *ObservatoriumAPI) makeOpaAms(amsURL, memcachedUrl, clientSecretName string) *k8sutil.Container {
	opts := &observatoriumapi.OpaAmsOptions{
		WebListen:               &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 8082},
		WebInternalListen:       &net.TCPAddr{IP: net.IPv4(0, 0, 0, 0), Port: 8083},
		WebHealthchecksURL:      "http://localhost:8082",
		LogLevel:                "warn",
		AmsURL:                  amsURL,
		ResourceTypePrefix:      "observatorium",
		OidcClientID:            "$(CLIENT_ID)",
		OidcClientSecret:        "$(CLIENT_SECRET)",
		OidcIssuerURL:           "$(ISSUER_URL)",
		OpaPackage:              "observatorium",
		Memcached:               memcachedUrl,
		MemcachedExpire:         300,
		InternalTracingEndpoint: &net.TCPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 6831},
	}

	ret := observatoriumapi.MakeOpaAms(opts, true)
	ret.ImageTag = "master-2022-11-03-222daab"
	ret.Env = append(ret.Env, k8sutil.NewEnvFromSecret("CLIENT_ID", clientSecretName, "client-id"))
	ret.Env = append(ret.Env, k8sutil.NewEnvFromSecret("CLIENT_SECRET", clientSecretName, "client-secret"))
	ret.Env = append(ret.Env, k8sutil.NewEnvFromSecret("ISSUER_URL", clientSecretName, "issuer-url"))

	return ret
}

func (o *ObservatoriumAPI) makeGubernator(name string) k8sutil.ObjectMap {
	gube := observatoriumapi.NewGubernatorDeployment(o.Namespace, gubernatorTag)
	gube.Image = gubernatorImage
	gube.Replicas = 1
	gube.Name = name
	executeIfNotNil(o.GubernatorPremanifestsHook, gube)

	// Post process
	manifests := gube.Manifests()
	postProcessServiceMonitor(k8sutil.GetObject[*monv1.ServiceMonitor](manifests, ""), gube.Namespace)
	addQuayPullSecret(k8sutil.GetObject[*corev1.ServiceAccount](manifests, ""))

	return manifests
}

func (o *ObservatoriumAPI) makeUp(name, endpoint string) k8sutil.ObjectMap {
	opts := &observatoriumup.UpOptions{}
	opts.LogLevel = log.LogLevelInfo
	opts.EndpointType = observatoriumup.EndpointTypeMetrics
	opts.EndpointRead = fmt.Sprintf("http://observatorium-thanos-query-frontend.%s.svc.cluster.local:9090", o.Namespace)
	zeroDur := time.Duration(0)
	opts.Duration = &zeroDur
	opts.QueriesFile = observatoriumup.NewQueriesFileOption(&observatoriumup.QueriesFile{
		Queries: []upoptions.QuerySpec{
			{
				Name:  "query-path-sli-1M-samples",
				Query: fmt.Sprintf("avg_over_time(avalanche_metric_mmmmm_0_0{tenant_id=\"%s\"}[1h])", o.UpQueriesTenant),
			},
			{
				Name:  "query-path-sli-10M-samples",
				Query: fmt.Sprintf("avg_over_time(avalanche_metric_mmmmm_0_0{tenant_id=\"%s\"}[10h])", o.UpQueriesTenant),
			},
			{
				Name:  "query-path-sli-100M-samples",
				Query: fmt.Sprintf("avg_over_time(avalanche_metric_mmmmm_0_0{tenant_id=\"%s\"}[100h])", o.UpQueriesTenant),
			},
		},
	})
	executeIfNotNil(o.UpQueryFrontendOpts, opts)

	obsup := observatoriumup.NewUp(opts, o.Namespace, observatoriumUpTag)
	obsup.Image = observatoriumUpImage
	obsup.Name = name
	executeIfNotNil(o.UpQueryFrontendDeploy, obsup)

	// Post process
	manifests := obsup.Manifests()
	postProcessServiceMonitor(k8sutil.GetObject[*monv1.ServiceMonitor](manifests, ""), obsup.Namespace)
	addQuayPullSecret(k8sutil.GetObject[*corev1.ServiceAccount](manifests, obsup.Name))

	return manifests
}

func (o *ObservatoriumAPI) makeAvalanche() k8sutil.ObjectMap {
	opts := &avalanche.AvalancheOptions{}
	opts.MetricCount = 1
	opts.SeriesCount = 8333
	opts.RemoteURL = fmt.Sprintf("http://observatorium-thanos-receive-router.%s.svc.cluster.local:19291/api/v1/receive", o.Namespace)
	opts.RemoteWriteInterval = time.Duration(30) * time.Second
	opts.RemoteRequestsCount = 10e6
	opts.ValueInterval = 3600
	opts.SeriesInterval = 315360000 // 10y
	opts.MetricInterval = 315360000 // 10y
	opts.RemoteTenantHeader = "THANOS-TENANT"
	opts.RemoteTenant = o.UpQueriesTenant
	executeIfNotNil(o.AvalancheOpts, opts)

	aval := avalanche.NewAvalanche(opts, o.Namespace, avalancheTag)
	aval.Image = avalancheImage
	executeIfNotNil(o.AvalancheDeploy, aval)

	// Post process
	manifests := aval.Manifests()
	postProcessServiceMonitor(k8sutil.GetObject[*monv1.ServiceMonitor](manifests, ""), aval.Namespace)
	addQuayPullSecret(k8sutil.GetObject[*corev1.ServiceAccount](manifests, aval.Name))

	return manifests
}

func (o *ObservatoriumAPI) makeObsCtlReloader(obsApiName string) k8sutil.ObjectMap {
	depl := k8sutil.DeploymentGenericConfig{
		Name:                 "observatorium-obsctl-reloader",
		Namespace:            o.Namespace,
		Image:                obsctlReloaderImage,
		ImageTag:             obsctlReloaderTag,
		ImagePullPolicy:      corev1.PullIfNotPresent,
		Replicas:             1,
		EnableServiceMonitor: true,
		CommonLabels: map[string]string{
			k8sutil.NameLabel:      "rules-obsctl-reloader",
			k8sutil.InstanceLabel:  "observatorium",
			k8sutil.PartOfLabel:    "observatorium",
			k8sutil.ComponentLabel: "rules-obsctl-reloader",
			k8sutil.VersionLabel:   obsctlReloaderTag,
		},
		ContainerResources:            k8sutil.NewResourcesRequirements("50m", "", "500Mi", "2Gi"),
		TerminationGracePeriodSeconds: 30,
	}

	container := depl.ToContainer()
	container.Name = "obsctl-reloader"
	internalPort := 8081
	container.Args = []string{
		"--log.level=debug",
		fmt.Sprintf("--web.internal.listen=0.0.0.0:%d", internalPort),
		"--sleep-duration-seconds=16",
		fmt.Sprintf("--observatorium-api-url=http://%s.%s.svc.cluster.local:8080", obsApiName, o.Namespace),
		"--managed-tenants=" + strings.Join(o.ObsCtlReloaderManagedTenants, ","),
		"--issuer-url=https://sso.redhat.com/auth/realms/redhat-external",
		"--audience=observatorium",
		"--log-rules-enabled=false",
	}
	container.Ports = []corev1.ContainerPort{
		{
			Name:          "http",
			ContainerPort: int32(internalPort),
			Protocol:      corev1.ProtocolTCP,
		},
	}
	container.ServicePorts = []corev1.ServicePort{k8sutil.NewServicePort("http", internalPort, internalPort)}
	container.MonitorPorts = []monv1.Endpoint{{Port: "http"}}

	manifests := k8sutil.ObjectMap{}
	manifests.AddAll(depl.GenerateObjectsDeployment(container))

	postProcessServiceMonitor(k8sutil.GetObject[*monv1.ServiceMonitor](manifests, ""), depl.Namespace)
	addQuayPullSecret(k8sutil.GetObject[*corev1.ServiceAccount](manifests, depl.Name))

	rbacRole := &rbacv1.Role{
		TypeMeta:   k8sutil.RoleMeta,
		ObjectMeta: depl.ObjectMeta().MakeMeta(),
		Rules: []rbacv1.PolicyRule{
			{
				APIGroups: []string{"monitoring.coreos.com"},
				Resources: []string{"prometheusrules"},
				Verbs:     []string{"list", "watch", "get"},
			},
			{
				APIGroups: []string{"loki.grafana.com"},
				Resources: []string{"alertingrules", "recordingrules"},
				Verbs:     []string{"list", "watch", "get"},
			},
			{
				APIGroups: []string{""},
				Resources: []string{"secrets"},
				Verbs:     []string{"list", "watch", "get"},
			},
		},
	}
	manifests.Add(rbacRole)

	sa := k8sutil.GetObject[*corev1.ServiceAccount](manifests, depl.Name)
	roleBinding := &rbacv1.RoleBinding{
		TypeMeta:   k8sutil.RoleBindingMeta,
		ObjectMeta: depl.ObjectMeta().MakeMeta(),
		Subjects: []rbacv1.Subject{
			{
				Kind:      sa.GetObjectKind().GroupVersionKind().Kind,
				Name:      sa.GetName(),
				Namespace: sa.GetNamespace(),
			},
		},
		RoleRef: rbacv1.RoleRef{
			Kind:     rbacRole.GetObjectKind().GroupVersionKind().Kind,
			APIGroup: rbacRole.GetObjectKind().GroupVersionKind().Group,
			Name:     rbacRole.GetName(),
		},
	}
	manifests.Add(roleBinding)

	return manifests
}
